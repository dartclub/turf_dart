import 'dart:convert';
import 'dart:io';
import 'package:turf/turf.dart';

void main() async {
  // Process each input file
  await processFile('polygon_feature.geojson');
  await processFile('polygon.geojson');
  await processFile('point.geojson');
  await processFile('linestring.geojson');
  await processFile('multipolygon.geojson');
  await processFile('featurecollection.geojson');
  
  print('All files processed successfully!');
}

Future<void> processFile(String filename) async {
  try {
    final inputPath = 'test/examples/point_on_feature/in/$filename';
    final outputPath = 'test/examples/point_on_feature/out/$filename';
    
    print('Processing $inputPath');
    
    // Read the input file
    final file = File(inputPath);
    final jsonString = await file.readAsString();
    final geojson = jsonDecode(jsonString);
    
    // Parse the GeoJSON and create appropriate object based on type
    dynamic featureInput;
    
    if (geojson['type'] == 'Feature') {
      featureInput = Feature.fromJson(geojson);
    } else if (geojson['type'] == 'FeatureCollection') {
      featureInput = FeatureCollection.fromJson(geojson);
    } else {
      // For raw geometry objects, create a Feature with the geometry
      final geometry = parseGeometry(geojson);
      if (geometry != null) {
        featureInput = Feature(geometry: geometry);
      } else {
        print('  Unsupported geometry type: ${geojson['type']}');
        return;
      }
    }
    
    // Apply point_on_feature function
    final pointResult = pointOnFeature(featureInput);
    
    // Generate output - wrap in a FeatureCollection for better compatibility
    Map<String, dynamic> outputJson;
    
    if (pointResult != null) {
      final features = <Feature>[];
      
      // Create a new feature based on the input geometry
      GeometryObject? inputGeometry;
      if (featureInput is Feature) {
        inputGeometry = featureInput.geometry;
      } else if (featureInput is FeatureCollection && featureInput.features.isNotEmpty) {
        inputGeometry = featureInput.features[0].geometry;
      } else {
        inputGeometry = parseGeometry(geojson);
      }
      
      if (inputGeometry != null) {
        // Create a new feature with the input geometry
        final styledInputFeature = Feature(
          geometry: inputGeometry,
          properties: {
            'name': 'Input Geometry',
            'description': 'Original geometry from $filename'
          }
        );
        
        // Add styling based on geometry type
        if (inputGeometry is Polygon || inputGeometry is MultiPolygon) {
          styledInputFeature.properties!['stroke'] = '#0000FF';
          styledInputFeature.properties!['stroke-width'] = 2;
          styledInputFeature.properties!['fill'] = '#0000FF';
          styledInputFeature.properties!['fill-opacity'] = 0.2;
        } else if (inputGeometry is LineString || inputGeometry is MultiLineString) {
          styledInputFeature.properties!['stroke'] = '#0000FF';
          styledInputFeature.properties!['stroke-width'] = 2;
        } else if (inputGeometry is Point) {
          styledInputFeature.properties!['marker-color'] = '#0000FF';
        }
        
        features.add(styledInputFeature);
      }
      
      // Create a new feature for the point result to avoid modifying unmodifiable maps
      final styledPointResult = Feature(
        geometry: pointResult.geometry,
        properties: {
          'marker-color': '#FF0000',
          'marker-size': 'medium',
          'marker-symbol': 'star',
          'name': 'Point on Feature Result',
          'description': 'Point generated by pointOnFeature function'
        }
      );
      
      features.add(styledPointResult);
      
      outputJson = FeatureCollection(features: features).toJson();
      print('  Found point at coordinates: ${pointResult.geometry?.coordinates}');
    } else {
      // Create an empty FeatureCollection with error info in properties
      outputJson = {
        'type': 'FeatureCollection',
        'features': [
          {
            'type': 'Feature',
            'properties': {
              'error': 'Could not generate point for this input',
              'name': 'Error',
              'description': 'pointOnFeature function could not generate a point'
            },
            'geometry': null
          }
        ]
      };
      print('  Could not generate point for this input');
    }
    
    // Write to output file with pretty formatting
    final outputFile = File(outputPath);
    await outputFile.writeAsString(JsonEncoder.withIndent('  ').convert(outputJson));
    print('  Saved result to $outputPath');
  } catch (e) {
    print('Error processing $filename: $e');
  }
}

GeometryObject? parseGeometry(Map<String, dynamic> json) {
  final type = json['type'];
  
  switch (type) {
    case 'Point':
      return Point.fromJson(json);
    case 'LineString':
      return LineString.fromJson(json);
    case 'Polygon':
      return Polygon.fromJson(json);
    case 'MultiPoint':
      return MultiPoint.fromJson(json);
    case 'MultiLineString':
      return MultiLineString.fromJson(json);
    case 'MultiPolygon':
      return MultiPolygon.fromJson(json);
    case 'GeometryCollection':
      return GeometryCollection.fromJson(json);
    default:
      return null;
  }
}
